<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="app-title">RAG App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .container {
            background-color: white;
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 900px;
            width: 100%;
            height: 80vh; /* Set a fixed height for the chat window */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .chat-history {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            scroll-behavior: smooth;
        }
        .message {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1.5rem;
            margin-bottom: 0.75rem;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
        }
        .message.user {
            background-color: #2563eb;
            color: white;
            align-self: flex-end;
            margin-left: auto;
            border-bottom-right-radius: 0.5rem;
        }
        .message.ai {
            background-color: #f0f4f8;
            color: #333;
            align-self: flex-start;
            margin-right: auto;
            border-bottom-left-radius: 0.5rem;
        }
        .message.ai .controls {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .input-area {
            display: flex;
            padding-top: 1rem;
            gap: 0.5rem;
            align-items: center;
        }
        .input-area input {
            flex-grow: 1;
            padding: 0.75rem 1.25rem;
            border-radius: 2rem;
            border: 1px solid #d1d5db;
            background-color: #f9fafb;
            transition: all 0.2s;
        }
        .input-area input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }
        .input-area button {
            background-color: #3b82f6;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .input-area button:hover {
            background-color: #2563eb;
            transform: scale(1.05);
        }
        .input-area .icon-button {
            background-color: #d1d5db;
            color: #4b5563;
        }
        .input-area .icon-button:hover {
            background-color: #9ca3af;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .media-container {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f0f4f8;
            border-radius: 0.75rem;
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 200px;
            overflow: hidden;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">Welcome to Chat</h1>
        <h2 class="text-xl font-medium text-center text-gray-700 mb-4 hidden" id="user-welcome-message"></h2>

        <!-- Chat History Area -->
        <div id="chat-history" class="chat-history flex flex-col space-y-2">
            <!-- Messages will be appended here dynamically -->
        </div>
        
        <!-- Media Preview Area -->
        <div id="media-preview" class="media-container hidden">
            <!-- Media will be displayed here -->
        </div>

        <!-- Hidden input for file selection -->
        <input type="file" id="fileInput" class="hidden" accept="image/*,video/*,audio/*">

        <!-- Input Area -->
        <div class="input-area">
            <button id="newChatBtn" class="icon-button">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.055 7.143L6.157 9.245a8.25 8.25 0 0113.803 3.7l-3.181 3.182m-1.724-11.082L15.75 6.75l-3.182-3.182" />
                </svg>
            </button>
            <button id="generateImageBtn" class="icon-button">âœ¨</button>
            <button id="photoBtn" class="icon-button">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.3 2.3 0 0110 5.429a2.3 2.3 0 013.173.746H19.5a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9a2.25 2.25 0 012.25-2.25h.5z" />
                </svg>
            </button>
            <button id="videoBtn" class="icon-button">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" d="M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z" />
                </svg>
            </button>
            <button id="voiceBtn" class="icon-button">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5v3m6-3v-3m-6 3h.008V18h-.008zM6 12a6 6 0 016-6v-1.5m-6 7.5V18m6-3v-3m-6 3h-.008V18h-.008z" />
                </svg>
            </button>
            <input type="text" id="query" class="focus:outline-none" placeholder="Ask me anything...">
            <button id="submitBtn" class="flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />
                </svg>
            </button>
        </div>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- Global variables for Canvas environment ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        document.addEventListener('DOMContentLoaded', () => {
            const queryInput = document.getElementById('query');
            const submitBtn = document.getElementById('submitBtn');
            const photoBtn = document.getElementById('photoBtn');
            const videoBtn = document.getElementById('videoBtn');
            const voiceBtn = document.getElementById('voiceBtn');
            const generateImageBtn = document.getElementById('generateImageBtn');
            const newChatBtn = document.getElementById('newChatBtn');
            const chatHistory = document.getElementById('chat-history');
            const mediaPreview = document.getElementById('media-preview');
            const fileInput = document.getElementById('fileInput');
            const welcomeMessage = document.getElementById('user-welcome-message');
            const appTitle = document.getElementById('app-title');

            let mediaStream = null;
            let mediaRecorder = null;
            let audioChunks = [];
            let auth, userId;
            let uploadedImageBase64 = null;
            let uploadedImageMimeType = null;
            let chatHistoryData = [];

            // API configurations
            const textApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=`;
            const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=`;
            const ttsApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=`;
            // ðŸš¨ IMPORTANT: REPLACE THE EMPTY STRING BELOW WITH YOUR API KEY.
            // You can get a free API key at https://aistudio.google.com/app/apikey
            const apiKey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIIrjXdTB97UORVOsz+P+v4U19NiQMw65D0vfNi2pp4M/"; 

            // Helper for converting PCM to WAV
            function pcmToWav(pcmData, sampleRate) {
                const pcm16 = new Int16Array(pcmData);
                const buffer = new ArrayBuffer(44 + pcm16.length * 2);
                const view = new DataView(buffer);

                // RIFF identifier
                writeString(view, 0, 'RIFF');
                // file length
                view.setUint32(4, 36 + pcm16.length * 2, true);
                // RIFF type
                writeString(view, 8, 'WAVE');
                // format chunk identifier
                writeString(view, 12, 'fmt ');
                // format chunk length
                view.setUint32(16, 16, true);
                // sample format (raw)
                view.setUint16(20, 1, true);
                // channel count
                view.setUint16(22, 1, true);
                // sample rate
                view.setUint32(24, sampleRate, true);
                // byte rate (sample rate * block align)
                view.setUint32(28, sampleRate * 2, true);
                // block align (channel count * bytes per sample)
                view.setUint16(32, 2, true);
                // bits per sample
                view.setUint16(34, 16, true);
                // data chunk identifier
                writeString(view, 36, 'data');
                // data chunk length
                view.setUint32(40, pcm16.length * 2, true);

                // write the PCM samples
                for (let i = 0; i < pcm16.length; i++) {
                    view.setInt16(44 + i * 2, pcm16[i], true);
                }

                return new Blob([view], { type: 'audio/wav' });

                function writeString(view, offset, string) {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                }
            }

            // Add exponential backoff for API calls
            const callApiWithBackoff = async (payload, api, retries = 5, delay = 1000) => {
                try {
                    const response = await fetch(api + apiKey, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && retries > 0) {
                        console.error(`Rate limit exceeded. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        return callApiWithBackoff(payload, api, retries - 1, delay * 2);
                    }

                    if (!response.ok) {
                        const errorData = await response.text();
                        try {
                            const jsonError = JSON.parse(errorData);
                            throw new Error(`API error: ${response.status} - ${jsonError.error.message}`);
                        } catch {
                            throw new Error(`API error: ${response.status} - ${errorData}`);
                        }
                    }

                    const contentType = response.headers.get("content-type");
                    if (!contentType || !contentType.includes("application/json")) {
                        const text = await response.text();
                        console.error("Received non-JSON response:", text);
                        throw new Error("API returned an invalid or empty response. Please check the API endpoint and key.");
                    }
                    
                    const data = await response.json();
                    return data;

                } catch (error) {
                    console.error("Fetch failed:", error);
                    throw error;
                }
            };
            
            const addMessageToChat = (content, sender, parentElement, isImage = false) => {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message', sender);
                
                const contentDiv = document.createElement('div');
                if (isImage) {
                    const img = document.createElement('img');
                    img.src = content;
                    img.classList.add('rounded-xl', 'max-w-full', 'h-auto', 'object-contain', 'max-h-64');
                    contentDiv.appendChild(img);
                } else {
                    contentDiv.innerHTML = content;
                }
                
                messageDiv.appendChild(contentDiv);
                
                parentElement.appendChild(messageDiv);
                parentElement.scrollTop = parentElement.scrollHeight;

                if (sender === 'ai' && !isImage) {
                    const controlsDiv = document.createElement('div');
                    controlsDiv.classList.add('controls');
                    const ttsButton = document.createElement('button');
                    ttsButton.innerHTML = 'Read Aloud âœ¨';
                    ttsButton.classList.add('px-3', 'py-1', 'bg-blue-500', 'text-white', 'rounded-full', 'text-sm', 'hover:bg-blue-600', 'transition-colors', 'duration-200');
                    ttsButton.onclick = () => {
                        textToSpeech(contentDiv.textContent, ttsButton);
                    };
                    controlsDiv.appendChild(ttsButton);
                    messageDiv.appendChild(controlsDiv);
                }

                return contentDiv;
            };

            const generateContent = async (userQuery) => {
                // Add user message to chat history data and UI
                chatHistoryData.push({ role: 'user', parts: [{ text: userQuery }] });
                addMessageToChat(userQuery, 'user', chatHistory);

                if (!apiKey) {
                    addMessageToChat('<p class="text-red-500">API Key not configured. Please ensure you have a valid API key for your environment. If running this file outside of the Canvas, you must manually set the <code>apiKey</code> variable.</p>', 'ai', chatHistory);
                    return;
                }

                // Add AI message placeholder with loading spinner
                const aiResponsePlaceholder = addMessageToChat('<div class="loading-spinner"></div>', 'ai', chatHistory);
                
                try {
                    const parts = [{ text: userQuery }];
                    const isGreeting = ['hi', 'hello', 'hey', 'what\'s up', 'how are you'].some(greeting => userQuery.toLowerCase().startsWith(greeting));
                    let payload;

                    if (uploadedImageBase64) {
                        parts.push({
                            inlineData: {
                                mimeType: uploadedImageMimeType,
                                data: uploadedImageBase64
                            }
                        });
                        payload = {
                            contents: chatHistoryData,
                            systemInstruction: {
                                parts: [{ text: "You are a helpful assistant. Analyze the provided image and respond to the user's query." }]
                            },
                        };
                    } else if (isGreeting) {
                        payload = {
                            contents: chatHistoryData,
                            systemInstruction: {
                                parts: [{ text: "You are a friendly and helpful conversational AI. Respond in a brief and friendly manner." }]
                            },
                        };
                    } else {
                        payload = {
                            contents: chatHistoryData,
                            tools: [{ "google_search": {} }],
                            systemInstruction: {
                                parts: [{ text: "You are a helpful assistant. Provide a concise, single-paragraph summary of the key findings based on the provided search results. Include citations where appropriate." }]
                            },
                        };
                    }

                    const result = await callApiWithBackoff(payload, textApiUrl);
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        let text = candidate.content.parts[0].text;
                        
                        if (!uploadedImageBase64 && !isGreeting) {
                            const groundingMetadata = candidate.groundingMetadata;
                            if (groundingMetadata && groundingMetadata.groundingAttributions) {
                                const sources = groundingMetadata.groundingAttributions
                                    .map(attribution => ({
                                        uri: attribution.web?.uri,
                                        title: attribution.web?.title,
                                    }))
                                    .filter(source => source.uri && source.title);

                                if (sources.length > 0) {
                                    const sourceHtml = sources.map((source, index) => `
                                        <a href="${source.uri}" target="_blank" class="text-blue-600 hover:underline">
                                            [${index + 1}]
                                        </a>`).join('');
                                    text += `<div class="mt-4 text-xs text-gray-500">${sourceHtml}</div>`;
                                }
                            }
                        }
                        aiResponsePlaceholder.innerHTML = text;
                        // Add AI response to chat history data
                        chatHistoryData.push({ role: 'model', parts: [{ text: text }] });
                    } else {
                        aiResponsePlaceholder.innerHTML = '<p class="text-red-500">Could not generate a response. Please try a different query.</p>';
                    }
                } catch (error) {
                    console.error("An error occurred:", error);
                    aiResponsePlaceholder.innerHTML = `<p class="text-red-500">An error occurred while fetching the response: ${error.message}</p>`;
                } finally {
                    uploadedImageBase64 = null;
                    uploadedImageMimeType = null;
                    mediaPreview.classList.add('hidden');
                    mediaPreview.innerHTML = '';
                    queryInput.placeholder = 'Ask me anything...';
                }
            };

            const generateImage = async (userQuery) => {
                addMessageToChat(userQuery, 'user', chatHistory);

                if (!apiKey) {
                    addMessageToChat('<p class="text-red-500">API Key not configured. Please ensure you have a valid API key for your environment. If running this file outside of the Canvas, you must manually set the <code>apiKey</code> variable.</p>', 'ai', chatHistory);
                    return;
                }

                const aiResponsePlaceholder = addMessageToChat('<div class="loading-spinner"></div>', 'ai', chatHistory);

                try {
                    const payload = {
                        instances: [{ prompt: userQuery }],
                        parameters: { "sampleCount": 1 }
                    };

                    const result = await callApiWithBackoff(payload, imageApiUrl);
                    const imageBase64Data = result?.predictions?.[0]?.bytesBase64Encoded;

                    if (imageBase64Data) {
                        const imageUrl = `data:image/png;base64,${imageBase64Data}`;
                        aiResponsePlaceholder.innerHTML = '';
                        addMessageToChat(imageUrl, 'ai', chatHistory, true);
                    } else {
                        aiResponsePlaceholder.innerHTML = '<p class="text-red-500">Could not generate the image. Please try a different prompt.</p>';
                    }
                } catch (error) {
                    console.error("An error occurred:", error);
                    aiResponsePlaceholder.innerHTML = `<p class="text-red-500">An error occurred while generating the image: ${error.message}</p>`;
                } finally {
                    // Clean up UI state
                    queryInput.placeholder = 'Ask me anything...';
                    uploadedImageBase64 = null;
                    uploadedImageMimeType = null;
                    mediaPreview.classList.add('hidden');
                    mediaPreview.innerHTML = '';
                }
            };
            
            const textToSpeech = async (text, button) => {
                const originalText = button.textContent;
                button.textContent = '...';
                button.disabled = true;

                try {
                    const payload = {
                        contents: [{ parts: [{ text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Puck" }
                                }
                            }
                        },
                    };
                    const response = await callApiWithBackoff(payload, ttsApiUrl);
                    const audioPart = response?.candidates?.[0]?.content?.parts?.[0];

                    if (audioPart && audioPart.inlineData) {
                        const audioData = audioPart.inlineData.data;
                        const mimeType = audioPart.inlineData.mimeType;
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        
                        const pcmData = Uint8Array.from(atob(audioData), c => c.charCodeAt(0));
                        const wavBlob = pcmToWav(pcmData.buffer, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        
                        const audio = new Audio(audioUrl);
                        audio.play();

                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                        };
                    } else {
                        console.error("No audio data received from TTS API.");
                    }
                } catch (error) {
                    console.error("TTS failed:", error);
                } finally {
                    button.textContent = originalText;
                    button.disabled = false;
                }
            };
            
            // Initialize Firebase and Authentication
            let app;
            if (Object.keys(firebaseConfig).length > 0) {
                try {
                    app = initializeApp(firebaseConfig);
                    auth = getAuth(app);

                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            const userIdentifier = user.displayName || user.email || 'Guest';
                            welcomeMessage.textContent = `Hello, ${userIdentifier}!`;
                            welcomeMessage.classList.remove('hidden');
                            appTitle.textContent = `HI ${userIdentifier}`;
                        } else {
                                // Sign in anonymously if no user is found
                            if (initialAuthToken) {
                                try {
                                    await signInWithCustomToken(auth, initialAuthToken);
                                } catch (error) {
                                    console.error("Firebase custom auth failed:", error);
                                    await signInAnonymously(auth);
                                }
                            } else {
                                await signInAnonymously(auth);
                            }
                            welcomeMessage.classList.add('hidden');
                        }
                    });
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    welcomeMessage.textContent = 'Firebase is not configured. Some features may not work.';
                }
            } else {
                welcomeMessage.textContent = 'Firebase is not configured. Some features may not work.';
            }

            // Initial welcome message from the AI
            addMessageToChat('Hello! I am a RAG-powered chat assistant. You can ask me anything, upload images, or even generate new ones.', 'ai', chatHistory);

            // Functionality for Photo, Video, and Voice buttons
            const stopMedia = () => {
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }
                mediaPreview.classList.add('hidden');
                mediaPreview.innerHTML = '';
            };

            const handleSubmission = () => {
                const query = queryInput.value.trim();
                if (!query) {
                    return;
                }
                generateContent(query);
                queryInput.value = ''; // Clear the input field
            };

            submitBtn.addEventListener('click', handleSubmission);
            generateImageBtn.addEventListener('click', () => {
                const query = queryInput.value.trim();
                if (!query) {
                    return;
                }
                generateImage(query);
                queryInput.value = '';
            });

            newChatBtn.addEventListener('click', () => {
                chatHistoryData = [];
                chatHistory.innerHTML = '';
                addMessageToChat("Conversation history cleared. Start a new chat!", 'ai', chatHistory);
            });

            // Photo Button
            photoBtn.addEventListener('click', () => {
                stopMedia();
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64String = reader.result.split(',')[1];
                        uploadedImageBase64 = base64String;
                        uploadedImageMimeType = file.type;
                        
                        const url = URL.createObjectURL(file);
                        let mediaElement = document.createElement('img');
                        mediaElement.src = url;
                        mediaElement.classList.add('max-h-full', 'max-w-full', 'rounded-xl');
                        
                        mediaPreview.innerHTML = '';
                        mediaPreview.appendChild(mediaElement);
                        mediaPreview.classList.remove('hidden');
                        
                        queryInput.placeholder = 'Type your question about the image...';
                        addMessageToChat(`Image selected: ${file.name}`, 'ai', chatHistory);
                    };
                    reader.readAsDataURL(file);
                }
            });

            // Video Button
            videoBtn.addEventListener('click', async () => {
                stopMedia();
                uploadedImageBase64 = null;
                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    const videoElement = document.createElement('video');
                    videoElement.srcObject = mediaStream;
                    videoElement.autoplay = true;
                    videoElement.muted = true;
                    videoElement.classList.add('max-h-full', 'max-w-full', 'rounded-xl');
                    
                    mediaPreview.innerHTML = '';
                    mediaPreview.appendChild(videoElement);
                    mediaPreview.classList.remove('hidden');

                    addMessageToChat('Camera access granted. Live video preview is now active.', 'ai', chatHistory);
                } catch (err) {
                    addMessageToChat(`Error accessing camera: ${err.message}`, 'ai', chatHistory);
                }
            });

            // Voice Recording Button
            voiceBtn.addEventListener('click', async () => {
                stopMedia();
                uploadedImageBase64 = null;
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    addMessageToChat('Recording stopped.', 'ai', chatHistory);
                    return;
                }

                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(mediaStream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audioElement = document.createElement('audio');
                        audioElement.src = audioUrl;
                        audioElement.controls = true;
                        audioElement.classList.add('w-full', 'rounded-xl');
                        
                        mediaPreview.innerHTML = '';
                        mediaPreview.appendChild(audioElement);
                        mediaPreview.classList.remove('hidden');

                        stopMedia(); // Stop the live audio stream from the microphone
                    };

                    mediaRecorder.start();
                    addMessageToChat('Recording started. Click the mic button again to stop.', 'ai', chatHistory);
                } catch (err) {
                    addMessageToChat(`Error accessing microphone: ${err.message}`, 'ai', chatHistory);
                }
            });

            queryInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSubmission();
                }
            });
        });
    </script>
</body>
</html>
